# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Lean 4 formalization project for the [UW Math AI Winter 2026 program](https://sites.math.washington.edu/ai/winter2026.html) on algebraic geometry.

**Goal**: Formalize Lemmas 3.1 and 3.2 from [arXiv:2503.07846](https://arxiv.org/abs/2503.07846) - proving that an injective, finite, étale ring homomorphism between local rings is monogenic (i.e., the target ring is generated by a single element over the source).

## Build Commands
When iterating on lean, prefer to use VSCode diagnostics as they are much faster than running lake commands. However, something to be aware of: VSCode diagnostics take some time to update after each edit, especially if imports were changed.
```bash
# Build the project (downloads mathlib cache automatically if needed)
lake build

# Get mathlib cache (speeds up builds significantly)
lake exe cache get

# Update dependencies (run after changing lean-toolchain or lakefile.toml)
lake update

# Check a single file
lake env lean Monogenic/Basic.lean
```

## Architecture

### Core Files

- **`Monogenic.lean`** - Root import file and main theorem statement `Lemma_3_2` (incomplete, has sorries)
- **`Monogenic/Basic.lean`** - Defines `isMonogenicExtension` and proves `isMonogenicExtension_iff` equivalence
- **`Monogenic/Weak.lean`** - Main proof `FiniteInjectiveEtale_IsMonogenic` using Nakayama's lemma (has sorries for étale injectivity)
- **`Monogenic/Strong.lean`** - Defines `isStrongMonogenicExtension` requiring monic polynomial with unit derivative
- **`Monogenic/claude-normal.lean`** - Class-based `Monogenic` with additional hypotheses (integrally closed domain)

### Key Definitions

```lean
-- A ring map is monogenic if S ≃ R[X]/(f) for some polynomial f
def isMonogenicExtension (φ : R →+* S) : Prop :=
  ∃ f : R[X], Nonempty ((R[X] ⧸ Ideal.span {f}) ≃ₐ[R] S)

-- Strong version: f is monic and f'(β) is a unit
def isStrongMonogenicExtension [Algebra R S] : Prop :=
  ∃ f : R[X], ∃ ψ : ((R[X] ⧸ Ideal.span {f}) ≃ₐ[R] S),
    f.Monic ∧ IsUnit (eval (ψ ...) (derivative (map (algebraMap R S) f)))
```

### Proof Strategy

1. **Étale → maximal ideals match**: `Algebra.FormallyUnramified.map_maximalIdeal`
2. **Residue field is separable**: automatic from étale
3. **Primitive element theorem**: `Field.exists_primitive_element` gives generator β₀ over residue field
4. **Lift β₀ to β in S**: via `Ideal.Quotient.mk_surjective`
5. **Nakayama's lemma**: `Algebra.adjoin R {β} = ⊤`
6. **Construct isomorphism**: evaluation map R[X]/(f) → S is bijective

### Remaining Sorries

- Injectivity of evaluation map (needs étale properties or integrally closed hypothesis)
- `is_unit_minpoly_deriv`: derivative of minimal polynomial is a unit
- Base change étale preservation and tensor product isomorphisms in `Monogenic.lean`

## Key Mathlib Dependencies

- `Mathlib.RingTheory.Etale.Basic` - étale ring homomorphisms
- `Mathlib.RingTheory.Unramified.LocalRing` - unramified local rings
- `Mathlib.RingTheory.LocalRing.ResidueField.Defs` - residue fields
- `Mathlib.FieldTheory.PrimitiveElement` - primitive element theorem
- `Mathlib.RingTheory.AdjoinRoot` - polynomial quotient rings

## Mathematical Background

### Lemmas from the Paper

**Lemma 3.2** (étale case): Let (R, m_R) and (S, m_S) be regular local rings with R → S finite and étale. Then:
1. There exists β ∈ S with R[β] = S
2. If f(z) ∈ R[z] is β's minimal polynomial, then f'(β) ∈ S×

**Proof outline:**
1. Étale + S local ⟹ m_R·S = m_S (maximal ideals match)
2. Base change preserves étale ⟹ R/m_R → S/m_S is separable
3. Primitive element theorem ⟹ ∃ β₀ ∈ S/m_S with (R/m_R)[β₀] = S/m_S and f₀'(β₀) ≠ 0
4. Lift β₀ to β ∈ S
5. Nakayama's lemma ⟹ R[β] = S
6. f'(β) ≡ f₀'(β₀) ≠ 0 (mod m_S) ⟹ f'(β) is a unit

**Lemma 3.1** (partial étale case): Let (R, m_R) and (S, m_S) be regular local rings with R → S finite. If there exists a height 1 prime q₀ ⊂ S such that R/(q₀ ∩ R) → S/q₀ is étale, then S is monogenic over R.

**Proof outline:** Apply Lemma 3.2 to the étale quotient, lift β₀ to β, then adjust β by adding a generator of q₀ if needed to ensure R[β] = S.

### Connection to Stacks Project

The notion of monogenic extension is related to **standard étale** maps (Tag 00UB): R→S is standard étale if S ≅ R[x]_g/(f) where f is monic and f' is a unit. Every étale map is locally standard étale (Tag 00UE).

### Formalization Notes

- The current code formalizes Lemma 3.2 (the fully étale case)
- `isMonogenicExtension` captures condition (1): S ≅ R[X]/(f)
- `isStrongMonogenicExtension` adds condition (2): f is monic and f'(β) is a unit
- Injectivity of the evaluation map R[X]/(f) → S uses `minpoly.isIntegrallyClosed_dvd` when R is an integrally closed domain; the general case needs étale properties

## Import Guidelines

Avoid `import Mathlib` as it imports the entire library and causes slow builds/IDE loading. Use specific imports instead. Key imports for this project:

```lean
-- Étale ring theory
import Mathlib.RingTheory.Etale.Basic
import Mathlib.RingTheory.RingHom.Etale
import Mathlib.RingTheory.Unramified.LocalRing

-- Local rings and residue fields
import Mathlib.RingTheory.LocalRing.ResidueField.Defs

-- Field theory
import Mathlib.FieldTheory.PrimitiveElement
import Mathlib.FieldTheory.IntermediateField.Algebraic
import Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed

-- Ring theory
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Nakayama
import Mathlib.RingTheory.IntegralClosure.IntegrallyClosed
```
