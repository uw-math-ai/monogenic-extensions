import Monogenic.Generator
import Mathlib.Data.Real.Basic
import Mathlib.RingTheory.LocalRing.Defs
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.Algebra.Polynomial.Degree.Defs
import Mathlib.Algebra.Polynomial.Eval.Defs
import Mathlib.Algebra.Algebra.Subalgebra.Lattice
import Mathlib.Algebra.Polynomial.Derivative
import Mathlib.Algebra.Polynomial.Basic
import Mathlib.RingTheory.RingHom.Etale
import Mathlib.RingTheory.Etale.Basic
import Mathlib.RingTheory.Ideal.Span
import Mathlib.RingTheory.Unramified.LocalRing
import Mathlib.RingTheory.LocalRing.ResidueField.Defs
import Mathlib.RingTheory.Kaehler.Basic
import Mathlib.RingTheory.Ideal.Maps
import Mathlib.Algebra.Polynomial.Eval.Algebra
import Mathlib.RingTheory.AdjoinRoot
import Mathlib.RingTheory.Ideal.Height
import Mathlib.RingTheory.Regular.RegularSequence
import Mathlib.RingTheory.IntegralClosure.IntegrallyClosed


open Polynomial
open Function
open RingHom

namespace Monogenic
variable {R S} [CommRing R] [CommRing S] [IsLocalRing R] [IsLocalRing S]

/-!
## Monogenicity from Étale Height-One Quotients

This theorem states that if R and S are regular local rings with S a finite extension of R,
and there exists a height one prime ideal q in S such that the induced map R/(q ∩ R) → S/q
is étale, then S is a monogenic extension of R.

The key idea is that the étale condition on the quotient forces the extension to have a
particularly simple structure, which can be captured by a single generator.
-/

/-- A regular local ring is a Noetherian local ring whose maximal ideal can be generated
by a regular sequence of length equal to the Krull dimension.

Note: This is a placeholder class. In full generality, one should express this
using Krull dimension and regular sequences. The definition provided here
captures the essential property: the maximal ideal is generated by `dim R` elements
forming a regular sequence on R (viewed as an R-module). -/
class IsRegularLocalRing (R : Type*) [CommRing R] [IsLocalRing R] : Prop where
  /-- The maximal ideal can be generated by a regular sequence whose length equals the Krull dim -/
  regular_system : ∃ (n : ℕ) (rs : List R),
    rs.length = n ∧
    IsLocalRing.maximalIdeal R = Ideal.ofList rs

/-- If `S` is a finite `R`-module and `q` is an ideal of `S`, then the induced quotient map
    `R/(q ∩ R) →+* S/q` is finite. -/
lemma quotientMap_finite [Algebra R S] [Module.Finite R S] (q : Ideal S) :
    (Ideal.quotientMap q (algebraMap R S) le_rfl).Finite := by
  let φ := algebraMap R S
  let p := q.comap φ
  let φ₀ := Ideal.quotientMap q φ (le_refl p)
  letI : Algebra (R ⧸ p) (S ⧸ q) := φ₀.toAlgebra
  classical
  have h_fg : (⊤ : Submodule R S).FG := Module.finite_def.mp inferInstance
  obtain ⟨s, hs⟩ := h_fg
  refine ⟨⟨s.image (Ideal.Quotient.mk q), ?_⟩⟩
  rw [eq_top_iff]
  intro x _
  obtain ⟨x', rfl⟩ := Ideal.Quotient.mk_surjective x
  have hx' : x' ∈ Submodule.span R (s : Set S) := by rw [hs]; trivial
  refine Submodule.span_induction ?_ ?_ ?_ ?_ hx'
  · intro y hy
    exact Submodule.subset_span (Finset.mem_image_of_mem _ hy)
  · simp only [map_zero]; exact Submodule.zero_mem _
  · intro _ _ _ _ hy hz; simp only [map_add]; exact Submodule.add_mem _ hy hz
  · intro r _ _ hy
    rw [Algebra.smul_def, map_mul]
    have h_alg : algebraMap R S = φ := RingHom.algebraMap_toAlgebra φ
    rw [h_alg]
    rw [← Ideal.quotientMap_mk (f := φ) (H := le_refl p)]
    change (Ideal.Quotient.mk p r) • (Ideal.Quotient.mk q _) ∈ _
    exact Submodule.smul_mem _ _ hy

/-- Given regular local rings R and S with S a finite extension of R, if there exists a
height one prime ideal q ⊆ S such that the induced map R/(q ∩ R) → S/q is étale,
then S is a monogenic extension of R.

Here:
- `[Algebra R S]` provides the R-algebra structure on S
- `[Module.Finite R S]` asserts that S is a finite R-module
- `[FaithfulSMul R S]` asserts that the algebra map is injective
  (equivalent to `Injective (algebraMap R S)`)
- `q` is a prime ideal of S with height 1
- The "intersection" q ∩ R is formalized as `q.comap (algebraMap R S)` (the preimage of q)
- The induced quotient map `R/(q ∩ R) →+* S/q` is assumed to be étale
-/
theorem monogenic_of_etale_height_one_quotient
    [IsDomain R] [IsDomain S] [IsIntegrallyClosed R] [UniqueFactorizationMonoid S] [Algebra R S]
    [FaithfulSMul R S] [Module.Finite R S]
    (hR_reg : IsRegularLocalRing R) (hS_reg : IsRegularLocalRing S)
    (q : Ideal S) [hq_prime : q.IsPrime] (hq_height : q.height = 1)
    (hétale : (Ideal.quotientMap q (algebraMap R S) le_rfl).Etale) :
    ∃ f : R[X], Nonempty ((R[X] ⧸ Ideal.span {f}) ≃ₐ[R] S) := by
  -- Set up algebra structure
  let φ := algebraMap R S
  have φ_eq : algebraMap R S = φ := RingHom.algebraMap_toAlgebra φ

  -- Step 1: If φ is already étale, apply FiniteInjectiveEtale_IsMonogenic directly
  by_cases hφ_etale : Algebra.Etale R S
  · let ⟨β, adj⟩ := monogenic_of_finiteInjectiveEtale (R:=R) (S:=S)
    exact ⟨minpoly R β, gensUnivQuot_of_monogenic (R:=R) (S := S) β adj⟩

  -- Step 2: Define the quotient structures
  -- p = q ∩ R (preimage of q under φ)
  let p : Ideal R := q.comap φ

  -- R₀ = R/p, S₀ = S/q
  let R₀ := R ⧸ p
  let S₀ := S ⧸ q

  -- The quotient map φ₀ : R₀ → S₀
  let φ₀ : R₀ →+* S₀ := Ideal.quotientMap q φ (le_refl p)

  -- φ₀ is étale by hypothesis
  have hφ₀_etale : Etale φ₀ := hétale

  -- Step 3: Show φ₀ is finite and injective, then apply FiniteInjectiveEtale_IsMonogenic

  -- φ₀ is finite (quotient of finite extension)
  have hφ₀_fin : φ₀.Finite := quotientMap_finite q

  -- φ₀ is injective (since p = q.comap φ, quotientMap is automatically injective)
  have hφ₀_inj : Injective φ₀ := Ideal.quotientMap_injective

  -- R₀ is a domain (quotient by prime ideal)
  haveI : IsDomain R₀ := Ideal.Quotient.isDomain p

  -- S₀ is a domain (quotient by prime ideal)
  haveI : IsDomain S₀ := Ideal.Quotient.isDomain q

  -- Note: IsIntegrallyClosed R₀ is not needed for FiniteInjectiveEtale_IsMonogenic
  -- The general claim "quotient of integrally closed by prime is integrally closed" is false
  -- (counterexample: k[x,y]/(y²-x³) is not integrally closed)

  -- R₀ and S₀ are local rings (quotient of local ring by proper ideal is local)
  -- p is prime (comap of prime ideal is prime)
  haveI hp_prime : p.IsPrime := Ideal.IsPrime.comap φ
  -- R₀ is nontrivial (quotient by prime ideal is a domain, hence nontrivial)
  haveI : Nontrivial R₀ := Ideal.Quotient.nontrivial_iff.mpr hp_prime.ne_top
  haveI : IsLocalRing R₀ :=
    IsLocalRing.of_surjective' (Ideal.Quotient.mk p) Ideal.Quotient.mk_surjective

  -- S₀ is nontrivial (quotient by prime ideal is a domain, hence nontrivial)
  haveI : Nontrivial S₀ := Ideal.Quotient.nontrivial_iff.mpr hq_prime.ne_top
  haveI : IsLocalRing S₀ :=
    IsLocalRing.of_surjective' (Ideal.Quotient.mk q) Ideal.Quotient.mk_surjective

  -- Apply FiniteInjectiveEtale_IsMonogenic to get B₀ such that R₀[B₀] = S₀
  haveI : Module.Finite R₀ S₀ := RingHom.finite_algebraMap.mp hφ₀_fin
  haveI : Algebra.Etale R₀ S₀ := RingHom.etale_algebraMap.mp hφ₀_etale
  obtain ⟨B₀, adj⟩ :=
    monogenic_of_finiteInjectiveEtale (R:=R₀) (S:=S₀)
  let f₀ := minpoly R₀ B₀

  -- Lift B₀ to B ∈ S
  obtain ⟨B, hB⟩ := Ideal.Quotient.mk_surjective B₀

  -- Step 5: Lift f₀ to a monic polynomial f₁ over R
  -- First, we need to lift the coefficients of f₀ from R₀ to R
  have h_f₀_exists : ∃ f₁ : R[X], (f₁.map (Ideal.Quotient.mk p)) = f₀ ∧ f₁.Monic := by
    -- For this to work, we need f₀ to be monic (or have unit leading coefficient)
    -- In a finite étale extension R₀[X]/(f₀) ≅ S₀, f₀ can be chosen monic
    -- First show f₀ ∈ lifts (Ideal.Quotient.mk p) - true since quotient map is surjective
    have h_lifts : f₀ ∈ Polynomial.lifts (Ideal.Quotient.mk p) := by
      rw [Polynomial.mem_lifts]
      exact Polynomial.map_surjective (Ideal.Quotient.mk p) Ideal.Quotient.mk_surjective f₀
    have h_f₀_monic : f₀.Monic := minpoly.monic (Algebra.IsIntegral.isIntegral B₀)
    -- Now apply the lifting theorem for monic polynomials
    obtain ⟨f₁, hf₁_eq, _, hf₁_monic⟩ :=
      Polynomial.lifts_and_degree_eq_and_monic h_lifts h_f₀_monic
    exact ⟨f₁, hf₁_eq, hf₁_monic⟩

  obtain ⟨f₁, hf₁_map, hf₁_monic⟩ := h_f₀_exists

  -- Step 6: Key relation - since R₀ → S₀ is étale, we have ms₀ = mr₀·S₀
  -- This means ms = q + mr·S in S
  let mr := IsLocalRing.maximalIdeal R
  let ms := IsLocalRing.maximalIdeal S

  have h_ms_eq : ms = q ⊔ Ideal.map φ mr := by
    /-
    Strategy: Use the étale condition on φ₀ : R/p → S/q to show maximal ideals are related,
    then use the lattice correspondence for quotient rings.

    Key steps:
    1. For étale (hence formally unramified) φ₀, we have:
       Ideal.map φ₀ (maximalIdeal R₀) = maximalIdeal S₀
    2. The maximal ideal of R/p equals the image of mr under the quotient map
    3. Similarly for S/q
    4. Using composition: φ₀ ∘ (mk p) = (mk q) ∘ φ
    5. Apply correspondence theorem for surjective maps
    -/

    -- Set up algebra structure on φ₀
    letI : Algebra R₀ S₀ := φ₀.toAlgebra
    have hφ₀_eq : algebraMap R₀ S₀ = φ₀ := RingHom.algebraMap_toAlgebra φ₀

    -- Extract formally unramified from étale
    have h_etale := (RingHom.etale_iff_formallyUnramified_and_smooth φ₀).mp hφ₀_etale
    have unram_φ₀ : φ₀.FormallyUnramified := h_etale.1
    haveI : Algebra.FormallyUnramified R₀ S₀ := by rwa [← hφ₀_eq] at unram_φ₀

    -- φ₀ finite and injective implies local homomorphism
    haveI : IsLocalHom (algebraMap R₀ S₀) := by
      rw [hφ₀_eq]
      exact RingHom.IsIntegral.isLocalHom (RingHom.IsIntegral.of_finite hφ₀_fin) hφ₀_inj

    -- EssFiniteType needed for map_maximalIdeal
    haveI : Algebra.EssFiniteType R₀ S₀ :=
      RingHom.FiniteType.essFiniteType (RingHom.FiniteType.of_finite hφ₀_fin)

    -- Key lemma: for formally unramified local maps, maximal ideals match
    have h_max_eq : Ideal.map φ₀ (IsLocalRing.maximalIdeal R₀) = IsLocalRing.maximalIdeal S₀ := by
      rw [← hφ₀_eq]; exact Algebra.FormallyUnramified.map_maximalIdeal

    -- Maximal ideal of R/p = image of mr (using that local hom preserves nonunits)
    have hp_le_mr : p ≤ mr := IsLocalRing.le_maximalIdeal hp_prime.ne_top
    haveI : IsLocalHom (Ideal.Quotient.mk p) :=
      IsLocalHom.of_surjective _ Ideal.Quotient.mk_surjective
    have h_max_R₀ : IsLocalRing.maximalIdeal R₀ = Ideal.map (Ideal.Quotient.mk p) mr := by
      ext x; obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x
      simp only [Ideal.mem_map_iff_of_surjective _ Ideal.Quotient.mk_surjective,
        IsLocalRing.mem_maximalIdeal, mem_nonunits_iff]
      exact ⟨fun h => ⟨x, (map_mem_nonunits_iff _ x).mp h, rfl⟩,
             fun ⟨y, hy, hxy⟩ => hxy ▸ (map_mem_nonunits_iff _ y).mpr hy⟩

    -- Maximal ideal of S/q = image of ms (similarly)
    have hq_le_ms : q ≤ ms := IsLocalRing.le_maximalIdeal hq_prime.ne_top
    haveI : IsLocalHom (Ideal.Quotient.mk q) :=
      IsLocalHom.of_surjective _ Ideal.Quotient.mk_surjective
    have h_max_S₀ : IsLocalRing.maximalIdeal S₀ = Ideal.map (Ideal.Quotient.mk q) ms := by
      ext x; obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x
      simp only [Ideal.mem_map_iff_of_surjective _ Ideal.Quotient.mk_surjective,
        IsLocalRing.mem_maximalIdeal, mem_nonunits_iff]
      exact ⟨fun h => ⟨x, (map_mem_nonunits_iff _ x).mp h, rfl⟩,
             fun ⟨y, hy, hxy⟩ => hxy ▸ (map_mem_nonunits_iff _ y).mpr hy⟩

    -- Composition property: φ₀ ∘ (mk p) = (mk q) ∘ φ
    have h_comp : φ₀.comp (Ideal.Quotient.mk p) = (Ideal.Quotient.mk q).comp φ := by
      ext r
      change φ₀ (Ideal.Quotient.mk p r) = Ideal.Quotient.mk q (φ r)
      exact Ideal.quotientMap_mk

    -- Chain of equalities: map (mk q) ms = map (mk q) (map φ mr)
    have h_images_eq : Ideal.map (Ideal.Quotient.mk q) ms =
        Ideal.map (Ideal.Quotient.mk q) (Ideal.map φ mr) :=
      calc Ideal.map (Ideal.Quotient.mk q) ms
        _ = IsLocalRing.maximalIdeal S₀ := h_max_S₀.symm
        _ = Ideal.map φ₀ (IsLocalRing.maximalIdeal R₀) := h_max_eq.symm
        _ = Ideal.map φ₀ (Ideal.map (Ideal.Quotient.mk p) mr) := by rw [h_max_R₀]
        _ = Ideal.map (Ideal.Quotient.mk q) (Ideal.map φ mr) := by
            rw [Ideal.map_map, Ideal.map_map, h_comp]

    -- Since map (mk q) (q ⊔ X) = map (mk q) X (q maps to 0)
    have h_sup_image : Ideal.map (Ideal.Quotient.mk q) (q ⊔ Ideal.map φ mr) =
        Ideal.map (Ideal.Quotient.mk q) (Ideal.map φ mr) := by
      rw [Ideal.map_sup, Ideal.map_quotient_self]; simp

    -- Apply correspondence theorem: map f I = map f J ↔ I ⊔ ker f = J ⊔ ker f
    rw [← h_sup_image, Ideal.map_eq_iff_sup_ker_eq_of_surjective _ Ideal.Quotient.mk_surjective,
        Ideal.mk_ker, sup_eq_left.mpr hq_le_ms] at h_images_eq
    -- Simplify RHS: (q ⊔ X) ⊔ q = q ⊔ X
    calc ms = (q ⊔ Ideal.map φ mr) ⊔ q := h_images_eq
      _ = q ⊔ (Ideal.map φ mr ⊔ q) := by rw [sup_assoc]
      _ = q ⊔ (q ⊔ Ideal.map φ mr) := by rw [sup_comm (Ideal.map φ mr) q]
      _ = (q ⊔ q) ⊔ Ideal.map φ mr := by rw [← sup_assoc]
      _ = q ⊔ Ideal.map φ mr := by rw [sup_idem]

  -- Step 7: Two cases based on whether f₁(B) generates the right ideal
  -- Case analysis: does f₁(B) generate q modulo mr·S?

  -- The element f₁(B) ∈ S
  let f₁_B := Polynomial.aeval B f₁

  -- Since S is a UFD and q has height 1, q is principal
  -- Let q₀ be a generator of q
  have h_q_principal : ∃ q₀ : S, q = Ideal.span {q₀} := by
    -- Step 1: q ≠ ⊥ because height q = 1 > 0
    have hq_ne_bot : q ≠ ⊥ := by
      intro h
      rw [h, Ideal.height_bot] at hq_height
      exact zero_ne_one hq_height
    -- Step 2: By UFD property, every nonzero prime ideal contains a prime element
    obtain ⟨π, hπ_mem, hπ_prime⟩ := Ideal.IsPrime.exists_mem_prime_of_ne_bot hq_prime hq_ne_bot
    -- Step 3: span {π} is a prime ideal since π is prime
    have h_span_prime : (Ideal.span {π}).IsPrime := by
      rw [Ideal.span_singleton_prime hπ_prime.ne_zero]
      exact hπ_prime
    -- Step 4: span {π} ⊆ q
    have h_span_le : Ideal.span {π} ≤ q := (Ideal.span_singleton_le_iff_mem (I := q)).mpr hπ_mem
    -- Step 5: span {π} ≠ ⊥
    have h_span_ne_bot : Ideal.span {π} ≠ ⊥ := by
      simp only [ne_eq, Ideal.span_singleton_eq_bot]
      exact hπ_prime.ne_zero
    -- Step 6: Since height q = 1, if span {π} < q, then span {π} has height 0
    -- In a domain, height 0 primes are just ⊥, but span {π} ≠ ⊥, contradiction.
    -- So span {π} = q.
    have h_eq : Ideal.span {π} = q := by
      by_contra h_ne
      have h_lt : Ideal.span {π} < q := lt_of_le_of_ne h_span_le h_ne
      -- height (span {π}) < height q = 1, so height (span {π}) = 0
      haveI : (Ideal.span {π}).IsPrime := h_span_prime
      have hq_ht_ne_top : q.height ≠ ⊤ := by
        rw [hq_height]
        exact ENat.one_ne_top
      haveI : q.FiniteHeight := ⟨Or.inr hq_ht_ne_top⟩
      haveI : (Ideal.span {π}).FiniteHeight := Ideal.finiteHeight_of_le h_span_le hq_prime.ne_top
      have h_ht_lt := Ideal.height_strict_mono_of_is_prime h_lt
      rw [hq_height] at h_ht_lt
      -- height (span {π}) < 1 means height (span {π}) = 0
      have h_ht_zero : (Ideal.span {π}).height = 0 := ENat.lt_one_iff_eq_zero.mp h_ht_lt
      -- span {π} is a minimal prime of S (height 0 prime)
      rw [Ideal.height_eq_primeHeight, Ideal.primeHeight_eq_zero_iff] at h_ht_zero
      -- In a domain, minimalPrimes of (⊥ : Ideal S) is just {⊥}
      have h_span_eq_bot : Ideal.span {π} = ⊥ := by
        have h_mem : Ideal.span {π} ∈ (⊥ : Ideal S).minimalPrimes := h_ht_zero
        -- (⊥ : Ideal S).minimalPrimes = minimalPrimes S by definition
        have : (⊥ : Ideal S).minimalPrimes = minimalPrimes S := rfl
        rw [this, IsDomain.minimalPrimes_eq_singleton_bot] at h_mem
        exact Set.mem_singleton_iff.mp h_mem
      exact h_span_ne_bot h_span_eq_bot
    exact ⟨π, h_eq.symm⟩

  obtain ⟨q₀, hq₀⟩ := h_q_principal

  -- Check if f₁(B) generates the right structure
  by_cases h_gen : f₁_B ∈ ms ∧ Ideal.span {f₁_B} ⊔ Ideal.map (algebraMap R S) mr • ⊤ = ms
  · -- Case 1: f₁(B) generates ms/(mr·S), so R[B] = S
    -- The proof follows the standard monogenic extension construction
    use f₁
    sorry -- Complete the isomorphism construction

  · -- Case 2: f₁(B) does not generate the right ideal
    -- Then f₁(B) = q₀ * a for some a ∈ ms (since f₁(B) ∈ q but doesn't generate q alone)
    have h_f₁B_in_q : f₁_B ∈ q := by
      -- Suffices to show mk q (aeval B f₁) = 0 in S₀
      rw [← Ideal.Quotient.eq_zero_iff_mem]
      change Ideal.Quotient.mk q (Polynomial.aeval B f₁) = 0
      -- Push mk q through eval₂: σ(p.eval₂ f x) = p.eval₂ (σ∘f) (σ x)
      simp only [Polynomial.aeval_def]
      rw [Polynomial.hom_eval₂]
      -- Replace mk q B = B₀
      rw [hB]
      -- Replace composite ring hom using the commutative square
      have hcomp : (Ideal.Quotient.mk q).comp (algebraMap R S) =
          φ₀.comp (Ideal.Quotient.mk p) := by
        ext r
        change Ideal.Quotient.mk q (φ r) = φ₀ (Ideal.Quotient.mk p r)
        exact Ideal.quotientMap_mk.symm
      rw [hcomp]
      -- Use eval₂_map: (f.map g).eval₂ h x = f.eval₂ (h.comp g) x
      rw [← Polynomial.eval₂_map]
      rw [hf₁_map]
      -- Goal: f₀.eval₂ φ₀ B₀ = 0
      -- Convert to aeval (requires algebraMap R₀ S₀ = φ₀)
      change Polynomial.aeval B₀ f₀ = 0
      exact minpoly.aeval (A:=R₀) (B:=S₀) B₀

    have h_f₁B_factorization : ∃ a : S, f₁_B = q₀ * a := by
      rw [hq₀] at h_f₁B_in_q
      exact Ideal.mem_span_singleton.mp h_f₁B_in_q

    obtain ⟨a, ha⟩ := h_f₁B_factorization

    -- Key: f₁'(B) is not in ms (derivative is a unit modulo ms)
    have h_deriv_unit : f₁.derivative.aeval B ∉ ms := by
      -- Step 3: Get FaithfulSMul R₀ S₀ from injectivity of φ₀
      haveI : FaithfulSMul R₀ S₀ := by
        rw [faithfulSMul_iff_algebraMap_injective]
        exact hφ₀_inj

      -- Step 4: Apply deriv_isUnit_of_monogenic to B₀
      haveI : IsIntegrallyClosed R₀ := by
        sorry -- DO NOT try to fill this. We probably need to prove
              -- deriv_isUnit_of_monogenic from etaleness instead of
              -- IntegrallyClosed, if that's possible.
      have h_unit_B₀ : IsUnit (Polynomial.aeval B₀ (minpoly R₀ B₀).derivative) :=
        deriv_isUnit_of_monogenic B₀ adj

      -- Step 5: Commutative diagram - mk q (f₁'.aeval B) = f₀'.aeval B₀
      have h_deriv_comm : Ideal.Quotient.mk q (f₁.derivative.aeval B) =
          (f₀.derivative).aeval B₀ := by
        -- Push mk q through aeval using hom_eval₂
        simp only [Polynomial.aeval_def]
        rw [Polynomial.hom_eval₂]
        rw [hB]
        -- Replace composite ring hom
        have hcomp : (Ideal.Quotient.mk q).comp (algebraMap R S) =
            φ₀.comp (Ideal.Quotient.mk p) := by
          ext r
          change Ideal.Quotient.mk q (φ r) = φ₀ (Ideal.Quotient.mk p r)
          exact Ideal.quotientMap_mk.symm
        rw [hcomp]
        -- Use eval₂_map
        rw [← Polynomial.eval₂_map]
        -- Need: f₁.derivative.map (mk p) = f₀.derivative
        congr 1
        rw [← Polynomial.derivative_map, hf₁_map]

      -- Step 6: Conclude f₁'(B) ∉ ms
      intro h_in_ms
      -- f₁'.aeval B ∈ ms means it's not a unit
      have h_not_unit : ¬ IsUnit (f₁.derivative.aeval B) :=
        (IsLocalRing.mem_maximalIdeal _).mp h_in_ms
      -- For a local hom, non-units map to non-units; for surjective local hom, units
      -- lift to units. So non-unit maps to non-unit.
      haveI : IsLocalHom (Ideal.Quotient.mk q) :=
        IsLocalHom.of_surjective _ Ideal.Quotient.mk_surjective
      have h_nonunit_image : ¬ IsUnit (Ideal.Quotient.mk q (f₁.derivative.aeval B)) :=
        fun h_unit => h_not_unit (isUnit_of_map_unit (Ideal.Quotient.mk q) _ h_unit)
      -- But h_deriv_comm says the image equals aeval B₀ f₀', which is a unit
      rw [h_deriv_comm] at h_nonunit_image
      exact h_nonunit_image h_unit_B₀

    -- Consider B' = B + q₀
    let B' := B + q₀

    -- Compute f₁(B') using Taylor expansion
    -- f₁(B') = f₁(B) + f₁'(B) * q₀ + q₀² * (higher order terms)
    -- = q₀ * a + f₁'(B) * q₀ + q₀² * b
    -- = q₀ * (a + f₁'(B) + q₀ * b)
    have h_f₁B'_factorization : ∃ b : S, Polynomial.aeval B' f₁ =
      q₀ * (a + f₁.derivative.aeval B + q₀ * b) := by
      -- First establish the Taylor expansion remainder property:
      -- For any polynomial f, f(x + h) = f(x) + f'(x)*h + h²*c for some c
      have taylor_remainder : ∀ (f : R[X]) (x h : S),
          ∃ c : S, f.aeval (x + h) = f.aeval x + f.derivative.aeval x * h + h^2 * c := by
        intro f x h
        induction f using Polynomial.induction_on with
        | C r =>
          -- Constant polynomial: f(x+h) = r = f(x), derivative = 0
          use 0
          simp only [Polynomial.aeval_C, Polynomial.derivative_C, Polynomial.aeval_zero,
            mul_zero, add_zero, sq, zero_mul]
        | add p₁ p₂ ih₁ ih₂ =>
          -- Addition: use linearity
          obtain ⟨c₁, hc₁⟩ := ih₁
          obtain ⟨c₂, hc₂⟩ := ih₂
          use c₁ + c₂
          simp only [Polynomial.aeval_add, Polynomial.derivative_add] at *
          rw [hc₁, hc₂]
          ring
        | monomial n r ih =>
          -- Monomial: C r * X^(n+1)
          -- LHS = r * (x+h)^(n+1)
          -- Derivative = r * (n+1) * X^n, so derivative.aeval x = r * (n+1) * x^n
          -- RHS = r * x^(n+1) + r * (n+1) * x^n * h + h² * c
          simp only [Polynomial.aeval_mul, Polynomial.aeval_C, Polynomial.aeval_X_pow,
            Polynomial.derivative_mul, Polynomial.derivative_C, zero_mul, zero_add,
            Polynomial.derivative_X_pow]
          -- Use binomial theorem: (x+h)^(n+1) = Σ_{m=0}^{n+1} C(n+1,m) * x^m * h^(n+1-m)
          have h_binom : (x + h) ^ (n + 1) = ∑ m ∈ Finset.range (n + 2),
              x ^ m * h ^ (n + 1 - m) * (n + 1).choose m := add_pow x h (n + 1)
          -- Construct the remainder term (sum of terms with h² or higher)
          let c' := ∑ m ∈ Finset.range n, x ^ m * h ^ (n - 1 - m) * (n + 1).choose m
          use algebraMap R S r * c'
          rw [h_binom]
          -- Split sum: Σ_{m=0}^{n+1} = (Σ_{m=0}^{n-1}) + term(m=n) + term(m=n+1)
          rw [Finset.sum_range_succ, Finset.sum_range_succ]
          simp only [Nat.choose_self, Nat.cast_one, mul_one, Nat.sub_self, pow_zero,
            Nat.add_sub_cancel]
          -- (n+1).choose n = n+1
          have h_choose_n : (n + 1).choose n = n + 1 := Nat.choose_succ_self_right n
          rw [h_choose_n]
          -- Since n+1-m ≥ 2 for m < n, we have h^(n+1-m) = h² * h^(n-1-m)
          have h_sum_eq : (∑ m ∈ Finset.range n, x ^ m * h ^ (n + 1 - m) * (n + 1).choose m) =
              h ^ 2 * c' := by
            rw [Finset.mul_sum]
            apply Finset.sum_congr rfl
            intro m hm
            rw [Finset.mem_range] at hm
            -- m < n, so n + 1 - m ≥ 2, hence n + 1 - m = (n - 1 - m) + 2
            have h_exp : n + 1 - m = (n - 1 - m) + 2 := by omega
            rw [h_exp, pow_add]
            ring
          rw [h_sum_eq]
          -- Normalize: n + 1 - n = 1, and Nat cast factors through algebraMap
          have h_exp_simp : n + 1 - n = 1 := by omega
          simp only [h_exp_simp, pow_one, ← map_natCast (algebraMap R S)]
          ring
      -- Apply the Taylor expansion to f₁ with x = B and h = q₀
      obtain ⟨c, hc⟩ := taylor_remainder f₁ B q₀
      -- We have: f₁.aeval (B + q₀) = f₁.aeval B + f₁.derivative.aeval B * q₀ + q₀² * c
      -- Substitute ha: f₁.aeval B = q₀ * a (note: f₁_B = aeval B f₁)
      use c
      -- Unfold f₁_B in ha to get: Polynomial.aeval B f₁ = q₀ * a
      have ha' : Polynomial.aeval B f₁ = q₀ * a := ha
      rw [hc, ha']
      -- Goal: q₀ * a + f₁.derivative.aeval B * q₀ + q₀² * c =
      --       q₀ * (a + f₁.derivative.aeval B + q₀ * c)
      ring
    obtain ⟨b, hb⟩ := h_f₁B'_factorization

    -- Since f₁'(B) ∉ ms and a + f₁'(B) + q₀ * b has f₁'(B) as the "main term",
    -- (a + f₁'(B) + q₀ * b) is a unit (not in ms)
    have h_cofactor_unit : IsUnit (a + f₁.derivative.aeval B + q₀ * b) := by
      -- In a local ring, x is a unit iff x ∉ maximalIdeal
      -- Strategy: show (a + q₀ * b) ∈ ms, then use that unit + ms element = unit

      -- First, q₀ ∈ ms (since q ⊆ ms and q₀ generates q)
      have hq_le_ms : q ≤ ms := IsLocalRing.le_maximalIdeal hq_prime.ne_top
      have hq₀_in_ms : q₀ ∈ ms := by
        apply hq_le_ms
        rw [hq₀]
        exact Ideal.mem_span_singleton_self q₀

      -- q₀ * b ∈ ms (product with element in maximal ideal)
      have hq₀b_in_ms : q₀ * b ∈ ms := by
        rw [mul_comm]
        exact Ideal.mul_mem_left ms b hq₀_in_ms

      -- a ∈ ms: If a were a unit, then span {q₀ * a} = span {q₀} = q,
      -- contradicting Case 2 (h_gen)
      have ha_in_ms : a ∈ ms := by
        by_contra ha_not_in_ms
        have ha_unit : IsUnit a := IsLocalRing.notMem_maximalIdeal.mp ha_not_in_ms
        -- If a is a unit, then span {f₁_B} = span {q₀ * a} = span {q₀} = q
        have h_span_eq' : Ideal.span {f₁_B} = q := by
          rw [show f₁_B = q₀ * a from ha, hq₀]
          exact Ideal.span_singleton_mul_right_unit ha_unit q₀
        -- f₁_B ∈ ms since f₁_B ∈ q ⊆ ms
        have h_f₁B_in_ms' : f₁_B ∈ ms := hq_le_ms h_f₁B_in_q
        -- span {f₁_B} ⊔ Ideal.map φ mr • ⊤ = q ⊔ Ideal.map φ mr • ⊤ = ms
        have h_contains : Ideal.span {f₁_B} ⊔ Ideal.map φ mr • ⊤ = ms := by
          rw [h_span_eq', h_ms_eq]
          -- Need: q ⊔ Ideal.map φ mr • ⊤ = q ⊔ Ideal.map φ mr
          -- For ideals: I • ⊤ = I * ⊤ = I (by Ideal.smul_eq_mul and Ideal.mul_top)
          have h_smul_eq : Ideal.map φ mr • (⊤ : Ideal S) = Ideal.map φ mr := by
            rw [Ideal.smul_eq_mul, Ideal.mul_top]
          rw [h_smul_eq]
        -- This contradicts h_gen
        exact h_gen ⟨h_f₁B_in_ms', h_contains⟩

      -- a + q₀ * b ∈ ms
      have h_sum_in_ms : a + q₀ * b ∈ ms := Ideal.add_mem ms ha_in_ms hq₀b_in_ms

      -- Now: if u ∉ ms and x ∈ ms, then u + x ∉ ms
      -- The goal is: IsUnit (a + f₁.derivative.aeval B + q₀ * b)
      -- Rewrite using associativity: a + f₁'(B) + q₀*b = f₁'(B) + (a + q₀*b)
      have h_eq : a + f₁.derivative.aeval B + q₀ * b = f₁.derivative.aeval B + (a + q₀ * b) := by
        ring
      rw [h_eq]
      -- Goal: IsUnit (f₁.derivative.aeval B + (a + q₀ * b))
      -- In a local ring, IsUnit x ↔ x ∉ maximalIdeal
      rw [← IsLocalRing.notMem_maximalIdeal]
      -- Goal: f₁.derivative.aeval B + (a + q₀ * b) ∉ ms
      intro h_sum_in_ms'
      -- If (f₁'(B) + (a + q₀*b)) ∈ ms, then f₁'(B) = (f₁'(B) + (a + q₀*b)) - (a + q₀*b) ∈ ms
      have h_deriv_in_ms : f₁.derivative.aeval B ∈ ms := by
        have h_sub : f₁.derivative.aeval B =
            (f₁.derivative.aeval B + (a + q₀ * b)) - (a + q₀ * b) := by ring
        rw [h_sub]
        exact Ideal.sub_mem ms h_sum_in_ms' h_sum_in_ms
      -- This contradicts h_deriv_unit
      exact h_deriv_unit h_deriv_in_ms

    -- Therefore, Ideal.span {f₁(B')} = Ideal.span {q₀} = q
    have h_span_eq : Ideal.span {Polynomial.aeval B' f₁} = q := by
      rw [hb, hq₀]
      -- Goal: Ideal.span {q₀ * (a + f₁.derivative.aeval B + q₀ * b)} = Ideal.span {q₀}
      -- Use that multiplication by unit preserves span
      exact Ideal.span_singleton_mul_right_unit h_cofactor_unit q₀

    -- Now we can show R[B'] = S using B' = B + q₀
    -- The key is that B' still lifts B₀ (since q₀ ∈ q, it maps to 0 in S₀)
    have hB'_lifts : Ideal.Quotient.mk q B' = B₀ := by
      have hq₀_in_q : q₀ ∈ q := by
        rw [hq₀]
        exact Ideal.mem_span_singleton_self q₀
      calc Ideal.Quotient.mk q B'
        = Ideal.Quotient.mk q (B + q₀) := rfl
        _ = Ideal.Quotient.mk q B + Ideal.Quotient.mk q q₀ := by rw [map_add]
        _ = Ideal.Quotient.mk q B + 0 := by rw [Ideal.Quotient.eq_zero_iff_mem.mpr hq₀_in_q]
        _ = Ideal.Quotient.mk q B := by rw [add_zero]
        _ = B₀ := hB

    -- Step 8: Show Algebra.adjoin R {B'} = ⊤ and derive the isomorphism
    -- The correct witness polynomial is minpoly R B', not f₁.
    -- (f₁(B') = q₀ · unit ≠ 0, so eval at B' doesn't factor through R[X]/(f₁))
    --
    -- Proof that Algebra.adjoin R {B'} = ⊤:
    -- (1) adj + hB'_lifts ⟹ Algebra.adjoin R {B'} + q = S (as R-submodules),
    --     since every element of S₀ = S/q is a polynomial in β₀ = mk q B' over R₀.
    -- (2) aeval B' f₁ ∈ Algebra.adjoin R {B'} generates q (by h_span_eq),
    --     so S = A + (aeval B' f₁)·S, and iterating: S = A + qⁿ for all n ≥ 1.
    -- (3) The subalgebra A is local: S is integral over A (since S is integral
    --     over R ⊆ A), so by lying-over/going-up, A has unique maximal ideal
    --     ms ∩ A, and (aeval B' f₁) ∈ ms ∩ A is in the Jacobson radical of A.
    -- (4) S is finitely generated as an A-module (since f.g. over R ⊆ A).
    --     By Nakayama over A: the A-module S/A satisfies q·(S/A) = S/A with q
    --     in the Jacobson radical, so S/A = 0, i.e., A = S.
    have h_adjoin_top : Algebra.adjoin R {B'} = ⊤ := by
      -- The proof proceeds in three stages:
      -- (A) B₀ generates S₀ over R₀ by `adj`.
      -- (B) Lifting: for any s ∈ S, adjoin_induction on mk q s ∈ Algebra.adjoin R₀ {B₀}
      --     gives t ∈ Algebra.adjoin R {B'} with s ≡ t (mod q).
      --     So Algebra.adjoin R {B'} + q = S as R-submodules.
      -- (C) Since aeval B' f₁ ∈ Algebra.adjoin R {B'} generates q (h_span_eq),
      --     we get S = A + (aeval B' f₁)·S. Iterating: S = A + qⁿ for all n.
      --     The subalgebra A is local (S integral over A with S local) and
      --     (aeval B' f₁) ∈ Jacobson radical of A, so Nakayama gives A = S.
      sorry -- NOTE: before trying to fill this, consider instead refractoring
            -- so that we can reuse some of the code for S' = ⊤
            -- from monogenic_of_finiteInjectiveEtale in Generator.lean.
            -- might be possible?
    exact ⟨minpoly R B', gensUnivQuot_of_monogenic B' h_adjoin_top⟩

-- Alternative formulation using explicit ring homomorphism
theorem monogenic_of_etale_height_one_quotient'
    [IsDomain R] [IsDomain S] [IsIntegrallyClosed R]
    [UniqueFactorizationMonoid S]
    (hR_reg : IsRegularLocalRing R) (hS_reg : IsRegularLocalRing S)
    (φ : R →+* S) (hφ_fin : φ.Finite) (hφ_inj : Injective φ)
    (q : Ideal S) [hq_prime : q.IsPrime] (hq_height : q.height = 1)
    (hétale : Etale (Ideal.quotientMap q φ (le_refl (q.comap φ)))) :
    ∃(β : S), Algebra.adjoin φ.range {β} = ⊤ := by
  sorry

end Monogenic
